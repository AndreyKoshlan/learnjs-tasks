| Задача | Файлы |
| --- | --- |
| 14.5.1 Побитовый оператор и значение | [task1.js](task1.js) |
| 14.5.2 Проверка, целое ли число | [task2.js](task2.js) |
| 14.5.3 Симметричны ли операции ^, |, &? | [task3.js](task3.js) |
| 14.5.4 Почему результат разный? | [task4.js](task4.js) |

# 14.5.1 Побитовый оператор и значение
Почему побитовые операции в примерах ниже не меняют число? Что они делают внутри?
```javascript
alert( 123 ^ 0 ); // 123
alert( 0 ^ 123 ); // 123
alert( ~~123 ); // 123
```

**Решение**
```javascript
alert( 123 ^ 0 ); // 123 (к битам 123 прибавятся нули, ничего при этом не изменится)
alert( 0 ^ 123 ); // 123 (к нулевым битам прибавятся биты числа 123)
alert( ~~123 ); // 123 (дважды меняет биты на противоположные, тем самым возвращает прежние значения)
```

# 14.5.2 Проверка, целое ли число
Напишите функцию isInteger(num), которая возвращает true, если num – целое число, иначе false.
Например:
```javascript
alert( isInteger(1) ); // true
alert( isInteger(1.5) ); // false
alert( isInteger(-0.5) ); // false
```

**Решение**
```javascript
function isInteger(num) {
	return (num == ~~num);
}

console.log( isInteger(1) ); // true
console.log( isInteger(1.5) ); // false
console.log( isInteger(-0.5) ); // false
```

# 14.5.3 Симметричны ли операции ^, |, &?
Верно ли, что для любых a и b выполняются равенства ниже?
(a ^ b) == (b ^ a)
(a & b) == (b & a)
(a \| b) == (b \| a)
Иными словами, при перемене мест – всегда ли результат останется тем же?

**Решение**
```javascript
(a ^ b) == (b ^ a) // true, выполняется коммутативный закон
(a & b) == (b & a) // true, выполняется коммутативный закон
(a | b) == (b | a) // true, выполняется коммутативный закон
```

# 14.5.4 Почему результат разный?
Почему результат второго alert'а такой странный?
```javascript
alert( 123456789 ^ 0 ); // 123456789
alert( 12345678912345 ^ 0 ); // 1942903641
```

**Решение**
```javascript
alert( 123456789 ^ 0 ); // 123456789
alert( 12345678912345 ^ 0 ); // 1942903641

/* 
Почему результат второго alert'а такой странный?

Ответ: 12345678912345 число превысило Int32, в то время как побитовые
операторы работают с 32-битными числами и отбрасывают лишнюю часть
*/
```

