| Задача | Файлы |
| --- | --- |
| 6.1.1 Вычислить сумму чисел до данного | [task1.js](task1.js) |
| 6.1.2 Вычислить факториал | [task2.js](task2.js) |
| 6.1.3 Числа Фибоначчи | [task3.js](task3.js) |
| 6.1.4 Вывод односвязного списка | [task4.js](task4.js) |
| 6.1.5 Вывод односвязного списка в обратном порядке | [task5.js](task5.js) |

# 6.1.1 Вычислить сумму чисел до данного
Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.
Например:
```javascript
sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
```
Сделайте три варианта решения:
С использованием цикла.
Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1.
С использованием формулы арифметической прогрессии.
Пример работы вашей функции:
```javascript
function sumTo(n) { /*... ваш код ... */ }

alert( sumTo(100) ); // 5050
```
P.S. Какой вариант решения самый быстрый? Самый медленный? Почему?
P.P.S. Можно ли при помощи рекурсии посчитать sumTo(100000)?

**Решение**
```javascript
'use strict';

// С использованием цикла
function sumTo1(n) {
	let sum = 0;
	for (let i = n; i >= 1; i--) {
		sum += i;
	}
	return sum;
}

// Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1
function sumTo2(n) {
	return n > 1 ? n + sumTo2(n-1) : 1;
}

// С использованием формулы арифметической прогрессии
function sumTo3(n) {
	return n * (n + 1) / 2;
}

console.log( sumTo1(100) ); // С использованием цикла
console.log( sumTo2(100) ); // Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1
console.log( sumTo3(100) ); // С использованием формулы арифметической прогрессии

/* 
	Самый быстрый алгоритм с использованием формулы арифметической прогрессии, т.к.
	используется меньше всего операций с помощью только одной итерации. Самый долгий - рекурсивный.
	Рекурсивные алгоритмы работают медленнее чем их циклические аналоги.

	При помощи рекурсии может не получиться посчитать sumTo(100000). Возможно переполнение стека и вывод
	ошибки "Maximum call stack size exceeded".
*/
```

# 6.1.2 Вычислить факториал
Факториал натурального числа – это число, умноженное на "себя минус один", затем на "себя минус два", и так далее до 1. Факториал n обозначается как n!
Определение факториала можно записать как:
```javascript
n! = n * (n - 1) * (n - 2) * ...*1
```
Примеры значений для разных n:
```javascript
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
```
Задача – написать функцию factorial(n), которая возвращает n!, используя рекурсию.
```javascript
alert( factorial(5) ); // 120
```
P.S. Подсказка: n! можно записать как n \\* (n-1)! Например: 3! = 3\\*2! = 3\\*2\\*1! = 6

**Решение**
```javascript
'use strict';

function factorial(n) {
	return n > 1 ? n * factorial( n - 1 ) : 1;
}

console.log( factorial(5) ); // 120
```

# 6.1.3 Числа Фибоначчи
Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2. То есть, следующее число получается как сумма двух предыдущих.
Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
Числа Фибоначчи тесно связаны с золотым сечением и множеством природных явлений вокруг нас.
Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.
Пример работы:
```javascript
function fib(n) { /* ваш код */ }

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757
```
P.S. Все запуски функций из примера выше должны работать быстро. Вызов fib(77) должен занимать не более доли секунды.

**Решение**
```javascript
'use strict';

function fib(n) {
	let cache = new Map();

	function fibOptimized(n) {
		if (n <= 2)
			return 1;
		let nMinus2 = cache.get(n - 2) ?? fibOptimized(n - 2);
		let nMinus1 = cache.get(n - 1) ?? fibOptimized(n - 1);
		let result = nMinus2 + nMinus1;
		if (!cache.has(n))
			cache.set(n, result);
		return result;
	}

	return fibOptimized(n);
}

console.log(fib(3)); // 2
console.log(fib(7)); // 13
console.log(fib(77)); // 5527939700884757
```

# 6.1.4 Вывод односвязного списка
Допустим, у нас есть односвязный список (как описано в главе Рекурсия и стек):
```javascript
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```
Напишите функцию printList(list), которая выводит элементы списка по одному.
Сделайте два варианта решения: используя цикл и через рекурсию.
Как лучше: с рекурсией или без?

**Решение**
```javascript
'use strict';

// Используя цикл
function printList1(list) {
	let obj = list;
	while (obj) {
		console.log(obj.value);
		obj = obj.next;
	}
}

// Используя рекурсию
function printList2(list) {
	console.log( list.value );
	if (list.next)
		printList2(list.next);
}

let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

console.log('С использованием цикла');
printList1(list);

console.log('\nС использованием рекурсии');
printList2(list);

/* 
Вариант с использоваинем цикла превосходит вариант с использоваинем рекурсии, 
т.к. циклический алгоритм имеет наименьшее время выполнения и отсутствует недостаток переполнения стека
*/
```

# 6.1.5 Вывод односвязного списка в обратном порядке
Выведите односвязный список из предыдущего задания Вывод односвязного списка в обратном порядке.
Сделайте два решения: с использованием цикла и через рекурсию.

**Решение**
```javascript
'use strict';

// Используя цикл
function printList1(list) {
	let values = [];
  let obj = list;
	while (obj) {
    values.push(obj.value);
		obj = obj.next;
	}
  for (let i = values.length - 1; i >= 0; i--) {
    console.log(values[i]);
  }
}

// Используя рекурсию
function printList2(list) {
	if (list.next)
		printList2(list.next);
  console.log( list.value );
}

let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

console.log('С использованием цикла');
printList1(list);

console.log('\nС использованием рекурсии');
printList2(list);
```

